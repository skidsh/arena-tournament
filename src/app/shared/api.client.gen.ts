//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';

export module AzerothAPI {
export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param apiKey Access Token
     * @param body (optional) 
     * @return Success
     */
    auth(apiKey: any, body: SignInRequest | undefined, httpContext?: HttpContext): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/Account/Auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResponse>;
        }));
    }

    protected processAuth(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param username (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    checkUser(username: string | undefined, apiKey: any, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/Account/CheckUser?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param email (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    checkEmail(email: string | undefined, apiKey: any, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/Account/CheckEmail?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckEmail(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param apiKey Access Token
     * @param body (optional) 
     * @return Success
     */
    create(apiKey: any, body: CreateAccountRequest | undefined, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/Account/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param oldUser (optional) 
     * @param newUser (optional) 
     * @param currentPassword (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    updateUsername(oldUser: string | undefined, newUser: string | undefined, currentPassword: string | undefined, apiKey: any, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/Account/UpdateUsername?";
        if (oldUser === null)
            throw new Error("The parameter 'oldUser' cannot be null.");
        else if (oldUser !== undefined)
            url_ += "oldUser=" + encodeURIComponent("" + oldUser) + "&";
        if (newUser === null)
            throw new Error("The parameter 'newUser' cannot be null.");
        else if (newUser !== undefined)
            url_ += "newUser=" + encodeURIComponent("" + newUser) + "&";
        if (currentPassword === null)
            throw new Error("The parameter 'currentPassword' cannot be null.");
        else if (currentPassword !== undefined)
            url_ += "currentPassword=" + encodeURIComponent("" + currentPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateUsername(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param oldUser (optional) 
     * @param currentPassword (optional) 
     * @param newPassword (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    updatePassword(oldUser: string | undefined, currentPassword: string | undefined, newPassword: string | undefined, apiKey: any, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/Account/UpdatePassword?";
        if (oldUser === null)
            throw new Error("The parameter 'oldUser' cannot be null.");
        else if (oldUser !== undefined)
            url_ += "oldUser=" + encodeURIComponent("" + oldUser) + "&";
        if (currentPassword === null)
            throw new Error("The parameter 'currentPassword' cannot be null.");
        else if (currentPassword !== undefined)
            url_ += "currentPassword=" + encodeURIComponent("" + currentPassword) + "&";
        if (newPassword === null)
            throw new Error("The parameter 'newPassword' cannot be null.");
        else if (newPassword !== undefined)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdatePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param user (optional) 
     * @param pass (optional) 
     * @param newEmail (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    updateEmail(user: string | undefined, pass: string | undefined, newEmail: string | undefined, apiKey: any, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/Account/UpdateEmail?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (pass === null)
            throw new Error("The parameter 'pass' cannot be null.");
        else if (pass !== undefined)
            url_ += "pass=" + encodeURIComponent("" + pass) + "&";
        if (newEmail === null)
            throw new Error("The parameter 'newEmail' cannot be null.");
        else if (newEmail !== undefined)
            url_ += "newEmail=" + encodeURIComponent("" + newEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateEmail(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    getPosts(take: number | undefined, skip: number | undefined, apiKey: any, httpContext?: HttpContext): Observable<PostDTO[]> {
        let url_ = this.baseUrl + "/Blog/GetPosts?";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDTO[]>;
        }));
    }

    protected processGetPosts(response: HttpResponseBase): Observable<PostDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param jwt (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    deletePost(id: number | undefined, jwt: string | undefined, apiKey: any, httpContext?: HttpContext): Observable<PostDTO> {
        let url_ = this.baseUrl + "/Blog/DeletePost?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (jwt === null)
            throw new Error("The parameter 'jwt' cannot be null.");
        else if (jwt !== undefined)
            url_ += "jwt=" + encodeURIComponent("" + jwt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDTO>;
        }));
    }

    protected processDeletePost(response: HttpResponseBase): Observable<PostDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param apiKey Access Token
     * @param body (optional) 
     * @return Success
     */
    upsertPost(apiKey: any, body: CreatePostRequest | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/Blog/UpsertPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpsertPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param displayName (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    setDisplayName(userId: number | undefined, displayName: string | undefined, apiKey: any, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/Blog/SetDisplayName?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (displayName === null)
            throw new Error("The parameter 'displayName' cannot be null.");
        else if (displayName !== undefined)
            url_ += "displayName=" + encodeURIComponent("" + displayName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDisplayName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDisplayName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDisplayName(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    search(name: string | undefined, skip: number | undefined, take: number | undefined, apiKey: any, httpContext?: HttpContext): Observable<CharSearchResult> {
        let url_ = this.baseUrl + "/Character/Search?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CharSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CharSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<CharSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CharSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountName (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    searchByAccount(accountName: string | undefined, apiKey: any, httpContext?: HttpContext): Observable<CharSearchResult> {
        let url_ = this.baseUrl + "/Character/SearchByAccount?";
        if (accountName === null)
            throw new Error("The parameter 'accountName' cannot be null.");
        else if (accountName !== undefined)
            url_ += "accountName=" + encodeURIComponent("" + accountName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchByAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchByAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CharSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CharSearchResult>;
        }));
    }

    protected processSearchByAccount(response: HttpResponseBase): Observable<CharSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CharSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param characterName (optional) 
     * @param apiKey Access Token
     * @return Success
     */
    characterByName(characterName: string | undefined, apiKey: any, httpContext?: HttpContext): Observable<CharacterDetail> {
        let url_ = this.baseUrl + "/Character/CharacterByName?";
        if (characterName === null)
            throw new Error("The parameter 'characterName' cannot be null.");
        else if (characterName !== undefined)
            url_ += "characterName=" + encodeURIComponent("" + characterName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCharacterByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCharacterByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CharacterDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CharacterDetail>;
        }));
    }

    protected processCharacterByName(response: HttpResponseBase): Observable<CharacterDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CharacterDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param apiKey Access Token
     * @return Success
     */
    getRealm(apiKey: any, httpContext?: HttpContext): Observable<RealmDTO> {
        let url_ = this.baseUrl + "/Server/GetRealm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ApiKey": apiKey !== undefined && apiKey !== null ? "" + apiKey : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRealm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRealm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RealmDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RealmDTO>;
        }));
    }

    protected processGetRealm(response: HttpResponseBase): Observable<RealmDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RealmDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ArenaTeamInfo implements IArenaTeamInfo {
    name?: string | undefined;
    teamWeekWins?: number;
    teamWeekLosses?: number;
    personalWeekWins?: number;
    personalWeekLosses?: number;
    teamSeasonWins?: number;
    teamSeasonLosses?: number;
    personalSeasonWins?: number;
    personalSeasonLosses?: number;
    teamRating?: number;
    personalRating?: number;
    type?: number;

    constructor(data?: IArenaTeamInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.teamWeekWins = _data["teamWeekWins"];
            this.teamWeekLosses = _data["teamWeekLosses"];
            this.personalWeekWins = _data["personalWeekWins"];
            this.personalWeekLosses = _data["personalWeekLosses"];
            this.teamSeasonWins = _data["teamSeasonWins"];
            this.teamSeasonLosses = _data["teamSeasonLosses"];
            this.personalSeasonWins = _data["personalSeasonWins"];
            this.personalSeasonLosses = _data["personalSeasonLosses"];
            this.teamRating = _data["teamRating"];
            this.personalRating = _data["personalRating"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ArenaTeamInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ArenaTeamInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["teamWeekWins"] = this.teamWeekWins;
        data["teamWeekLosses"] = this.teamWeekLosses;
        data["personalWeekWins"] = this.personalWeekWins;
        data["personalWeekLosses"] = this.personalWeekLosses;
        data["teamSeasonWins"] = this.teamSeasonWins;
        data["teamSeasonLosses"] = this.teamSeasonLosses;
        data["personalSeasonWins"] = this.personalSeasonWins;
        data["personalSeasonLosses"] = this.personalSeasonLosses;
        data["teamRating"] = this.teamRating;
        data["personalRating"] = this.personalRating;
        data["type"] = this.type;
        return data;
    }
}

export interface IArenaTeamInfo {
    name?: string | undefined;
    teamWeekWins?: number;
    teamWeekLosses?: number;
    personalWeekWins?: number;
    personalWeekLosses?: number;
    teamSeasonWins?: number;
    teamSeasonLosses?: number;
    personalSeasonWins?: number;
    personalSeasonLosses?: number;
    teamRating?: number;
    personalRating?: number;
    type?: number;
}

export class AuthResponse implements IAuthResponse {
    username?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;
    isAdmin?: boolean;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.email = _data["email"];
            this.token = _data["token"];
            this.isAdmin = _data["isAdmin"];
        }
    }

    static fromJS(data: any): AuthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["email"] = this.email;
        data["token"] = this.token;
        data["isAdmin"] = this.isAdmin;
        return data;
    }
}

export interface IAuthResponse {
    username?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;
    isAdmin?: boolean;
}

export class CharacterDetail implements ICharacterDetail {
    name?: string | undefined;
    race?: number;
    gender?: number;
    class?: number;
    guild?: string | undefined;
    title?: string | undefined;
    skin?: number;
    face?: number;
    hairStyle?: number;
    hairColor?: number;
    faceStyle?: number;
    items?: Item[] | undefined;
    stats?: { [key: string]: number; } | undefined;
    arenaTeams?: ArenaTeamInfo[] | undefined;
    specName?: string | undefined;
    specs?: TalentSpec[] | undefined;

    constructor(data?: ICharacterDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.race = _data["race"];
            this.gender = _data["gender"];
            this.class = _data["class"];
            this.guild = _data["guild"];
            this.title = _data["title"];
            this.skin = _data["skin"];
            this.face = _data["face"];
            this.hairStyle = _data["hairStyle"];
            this.hairColor = _data["hairColor"];
            this.faceStyle = _data["faceStyle"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Item.fromJS(item));
            }
            if (_data["stats"]) {
                this.stats = {} as any;
                for (let key in _data["stats"]) {
                    if (_data["stats"].hasOwnProperty(key))
                        (<any>this.stats)![key] = _data["stats"][key];
                }
            }
            if (Array.isArray(_data["arenaTeams"])) {
                this.arenaTeams = [] as any;
                for (let item of _data["arenaTeams"])
                    this.arenaTeams!.push(ArenaTeamInfo.fromJS(item));
            }
            this.specName = _data["specName"];
            if (Array.isArray(_data["specs"])) {
                this.specs = [] as any;
                for (let item of _data["specs"])
                    this.specs!.push(TalentSpec.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CharacterDetail {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["race"] = this.race;
        data["gender"] = this.gender;
        data["class"] = this.class;
        data["guild"] = this.guild;
        data["title"] = this.title;
        data["skin"] = this.skin;
        data["face"] = this.face;
        data["hairStyle"] = this.hairStyle;
        data["hairColor"] = this.hairColor;
        data["faceStyle"] = this.faceStyle;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (this.stats) {
            data["stats"] = {};
            for (let key in this.stats) {
                if (this.stats.hasOwnProperty(key))
                    (<any>data["stats"])[key] = (<any>this.stats)[key];
            }
        }
        if (Array.isArray(this.arenaTeams)) {
            data["arenaTeams"] = [];
            for (let item of this.arenaTeams)
                data["arenaTeams"].push(item.toJSON());
        }
        data["specName"] = this.specName;
        if (Array.isArray(this.specs)) {
            data["specs"] = [];
            for (let item of this.specs)
                data["specs"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICharacterDetail {
    name?: string | undefined;
    race?: number;
    gender?: number;
    class?: number;
    guild?: string | undefined;
    title?: string | undefined;
    skin?: number;
    face?: number;
    hairStyle?: number;
    hairColor?: number;
    faceStyle?: number;
    items?: Item[] | undefined;
    stats?: { [key: string]: number; } | undefined;
    arenaTeams?: ArenaTeamInfo[] | undefined;
    specName?: string | undefined;
    specs?: TalentSpec[] | undefined;
}

export class CharResult implements ICharResult {
    name?: string | undefined;
    race?: number;
    gender?: number;
    class?: number;
    spec?: string | undefined;
    talentSpecs?: TalentSpec[] | undefined;
    arenaTeams?: ArenaTeamInfo[] | undefined;

    constructor(data?: ICharResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.race = _data["race"];
            this.gender = _data["gender"];
            this.class = _data["class"];
            this.spec = _data["spec"];
            if (Array.isArray(_data["talentSpecs"])) {
                this.talentSpecs = [] as any;
                for (let item of _data["talentSpecs"])
                    this.talentSpecs!.push(TalentSpec.fromJS(item));
            }
            if (Array.isArray(_data["arenaTeams"])) {
                this.arenaTeams = [] as any;
                for (let item of _data["arenaTeams"])
                    this.arenaTeams!.push(ArenaTeamInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CharResult {
        data = typeof data === 'object' ? data : {};
        let result = new CharResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["race"] = this.race;
        data["gender"] = this.gender;
        data["class"] = this.class;
        data["spec"] = this.spec;
        if (Array.isArray(this.talentSpecs)) {
            data["talentSpecs"] = [];
            for (let item of this.talentSpecs)
                data["talentSpecs"].push(item.toJSON());
        }
        if (Array.isArray(this.arenaTeams)) {
            data["arenaTeams"] = [];
            for (let item of this.arenaTeams)
                data["arenaTeams"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICharResult {
    name?: string | undefined;
    race?: number;
    gender?: number;
    class?: number;
    spec?: string | undefined;
    talentSpecs?: TalentSpec[] | undefined;
    arenaTeams?: ArenaTeamInfo[] | undefined;
}

export class CharSearchResult implements ICharSearchResult {
    characters?: CharResult[] | undefined;
    count?: number;

    constructor(data?: ICharSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["characters"])) {
                this.characters = [] as any;
                for (let item of _data["characters"])
                    this.characters!.push(CharResult.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CharSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CharSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.characters)) {
            data["characters"] = [];
            for (let item of this.characters)
                data["characters"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface ICharSearchResult {
    characters?: CharResult[] | undefined;
    count?: number;
}

export class CreateAccountRequest implements ICreateAccountRequest {
    username?: string | undefined;
    encodedPassword?: string | undefined;
    email?: string | undefined;

    constructor(data?: ICreateAccountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.encodedPassword = _data["encodedPassword"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CreateAccountRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["encodedPassword"] = this.encodedPassword;
        data["email"] = this.email;
        return data;
    }
}

export interface ICreateAccountRequest {
    username?: string | undefined;
    encodedPassword?: string | undefined;
    email?: string | undefined;
}

export class CreatePostRequest implements ICreatePostRequest {
    id?: number | undefined;
    title?: string | undefined;
    text?: string | undefined;
    jwt?: string | undefined;

    constructor(data?: ICreatePostRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.text = _data["text"];
            this.jwt = _data["jwt"];
        }
    }

    static fromJS(data: any): CreatePostRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePostRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["text"] = this.text;
        data["jwt"] = this.jwt;
        return data;
    }
}

export interface ICreatePostRequest {
    id?: number | undefined;
    title?: string | undefined;
    text?: string | undefined;
    jwt?: string | undefined;
}

export class Item implements IItem {
    id?: number;
    displayId?: number;
    displaySlot?: number;
    enchantVisual?: number;
    slot?: number;
    enchant?: number;
    gem1?: number;
    gem2?: number;
    gem3?: number;
    transmog?: number;
    equipedSetItems?: number[] | undefined;

    constructor(data?: IItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayId = _data["displayId"];
            this.displaySlot = _data["displaySlot"];
            this.enchantVisual = _data["enchantVisual"];
            this.slot = _data["slot"];
            this.enchant = _data["enchant"];
            this.gem1 = _data["gem1"];
            this.gem2 = _data["gem2"];
            this.gem3 = _data["gem3"];
            this.transmog = _data["transmog"];
            if (Array.isArray(_data["equipedSetItems"])) {
                this.equipedSetItems = [] as any;
                for (let item of _data["equipedSetItems"])
                    this.equipedSetItems!.push(item);
            }
        }
    }

    static fromJS(data: any): Item {
        data = typeof data === 'object' ? data : {};
        let result = new Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayId"] = this.displayId;
        data["displaySlot"] = this.displaySlot;
        data["enchantVisual"] = this.enchantVisual;
        data["slot"] = this.slot;
        data["enchant"] = this.enchant;
        data["gem1"] = this.gem1;
        data["gem2"] = this.gem2;
        data["gem3"] = this.gem3;
        data["transmog"] = this.transmog;
        if (Array.isArray(this.equipedSetItems)) {
            data["equipedSetItems"] = [];
            for (let item of this.equipedSetItems)
                data["equipedSetItems"].push(item);
        }
        return data;
    }
}

export interface IItem {
    id?: number;
    displayId?: number;
    displaySlot?: number;
    enchantVisual?: number;
    slot?: number;
    enchant?: number;
    gem1?: number;
    gem2?: number;
    gem3?: number;
    transmog?: number;
    equipedSetItems?: number[] | undefined;
}

export class PostDTO implements IPostDTO {
    id?: number;
    userId?: number;
    userName?: string | undefined;
    title?: string | undefined;
    text?: string | undefined;
    postDate?: Date | undefined;
    changedDate?: Date | undefined;

    constructor(data?: IPostDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.title = _data["title"];
            this.text = _data["text"];
            this.postDate = _data["postDate"] ? new Date(_data["postDate"].toString()) : <any>undefined;
            this.changedDate = _data["changedDate"] ? new Date(_data["changedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PostDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PostDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["title"] = this.title;
        data["text"] = this.text;
        data["postDate"] = this.postDate ? this.postDate.toISOString() : <any>undefined;
        data["changedDate"] = this.changedDate ? this.changedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPostDTO {
    id?: number;
    userId?: number;
    userName?: string | undefined;
    title?: string | undefined;
    text?: string | undefined;
    postDate?: Date | undefined;
    changedDate?: Date | undefined;
}

export class RealmDTO implements IRealmDTO {
    name?: string | undefined;
    population?: string | undefined;
    startTime?: Date;
    online?: boolean;
    onlinePlayers?: number;
    maxPlayers?: number;
    readonly averageLatency?: number;
    readonly uptime?: string | undefined;

    constructor(data?: IRealmDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.population = _data["population"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.online = _data["online"];
            this.onlinePlayers = _data["onlinePlayers"];
            this.maxPlayers = _data["maxPlayers"];
            (<any>this).averageLatency = _data["averageLatency"];
            (<any>this).uptime = _data["uptime"];
        }
    }

    static fromJS(data: any): RealmDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RealmDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["population"] = this.population;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["online"] = this.online;
        data["onlinePlayers"] = this.onlinePlayers;
        data["maxPlayers"] = this.maxPlayers;
        data["averageLatency"] = this.averageLatency;
        data["uptime"] = this.uptime;
        return data;
    }
}

export interface IRealmDTO {
    name?: string | undefined;
    population?: string | undefined;
    startTime?: Date;
    online?: boolean;
    onlinePlayers?: number;
    maxPlayers?: number;
    averageLatency?: number;
    uptime?: string | undefined;
}

export class SignInRequest implements ISignInRequest {
    username?: string | undefined;
    encodedPassword?: string | undefined;

    constructor(data?: ISignInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.encodedPassword = _data["encodedPassword"];
        }
    }

    static fromJS(data: any): SignInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["encodedPassword"] = this.encodedPassword;
        return data;
    }
}

export interface ISignInRequest {
    username?: string | undefined;
    encodedPassword?: string | undefined;
}

export class TalentSpec implements ITalentSpec {
    talentTrees?: TalentTree[] | undefined;
    active?: boolean;

    constructor(data?: ITalentSpec) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["talentTrees"])) {
                this.talentTrees = [] as any;
                for (let item of _data["talentTrees"])
                    this.talentTrees!.push(TalentTree.fromJS(item));
            }
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): TalentSpec {
        data = typeof data === 'object' ? data : {};
        let result = new TalentSpec();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.talentTrees)) {
            data["talentTrees"] = [];
            for (let item of this.talentTrees)
                data["talentTrees"].push(item.toJSON());
        }
        data["active"] = this.active;
        return data;
    }
}

export interface ITalentSpec {
    talentTrees?: TalentTree[] | undefined;
    active?: boolean;
}

export class TalentTree implements ITalentTree {
    name?: string | undefined;
    talents?: number[] | undefined;

    constructor(data?: ITalentTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["talents"])) {
                this.talents = [] as any;
                for (let item of _data["talents"])
                    this.talents!.push(item);
            }
        }
    }

    static fromJS(data: any): TalentTree {
        data = typeof data === 'object' ? data : {};
        let result = new TalentTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.talents)) {
            data["talents"] = [];
            for (let item of this.talents)
                data["talents"].push(item);
        }
        return data;
    }
}

export interface ITalentTree {
    name?: string | undefined;
    talents?: number[] | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

}
